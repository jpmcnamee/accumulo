package org.apache.hadoop.hbase.optimization;

import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.fs.FSDataOutputStream;
import org.apache.hadoop.fs.FileSystem;
import org.apache.hadoop.fs.Path;
import org.apache.hadoop.hbase.Cell;
import org.apache.hadoop.hbase.KeyValue;
import org.apache.hadoop.hbase.Tag;
import org.apache.hadoop.hbase.KeyValue.Type;
import org.apache.hadoop.hbase.codec.Codec;
import org.apache.hadoop.hbase.io.util.LRUDictionary;
import org.apache.hadoop.hbase.io.util.MyDictionary;
import org.apache.hadoop.hbase.regionserver.wal.CompressionContext;
import org.apache.hadoop.hbase.regionserver.wal.WALCellCodec;
import org.apache.hadoop.hbase.regionserver.wal.WritableKeyValue;
import org.apache.hadoop.hbase.util.FSUtils;

public class WalOptimizationTest {
	private static List<byte[]> wordList;
	
	public static void buildListFromFile(String file) {
		wordList = new ArrayList<byte[]>();
		try{
		    BufferedReader reader = new BufferedReader(new FileReader(file));
		    String word = reader.readLine();
		    
		    while(word != null) {
		    	wordList.add(word.getBytes());
		        word = reader.readLine();
		    }
		    reader.close();
		} catch (Exception e) {
		    e.printStackTrace();
		}
		Collections.shuffle(wordList);
		
	}
	
	public static byte[] randomWord(int length) {
		int num = (int) (Math.random() * length);
		return wordList.get(num);
	}
	
	public static void main(String[] args) throws IOException, SecurityException, NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException {
		int entropy = -1;
		int rows = 100;
		int columns = 1;
		String loc = null, words = "/usr/share/dict/words";
		
		try {
		if (args.length == 0) {
			System.out.println("Usage: WalOptimization /path/to/wal rows cols entropy /path/to/wordlist");
			return;
		}
		if (args.length >= 1) {
			loc = args[0];
			System.out.println("Writing WAL to: " + loc);
		} else {
			System.out.println("please specifiy file location");
			return;
		}
		
		if (args.length >= 2) {
			rows = Integer.parseInt(args[1]);
		}
		if (args.length >= 3) {
			columns = Integer.parseInt(args[2]);
		}
		if (args.length >= 4) {
			entropy = Integer.parseInt(args[3]);
		}
		if (args.length >= 5) {
			words = args[4];
		}
		} catch (Exception e) {
			System.out.println("An error occured!");
			System.out.println("Usage: WalOptimization /path/to/wal rows cols entropy /path/to/wordlist");
			return;
		}
		CompressionContext compressionContext = new CompressionContext(LRUDictionary.class, false, false);
		WALCellCodec codec = WALCellCodec.create(new Configuration(), compressionContext);
		FileSystem fs = FileSystem.get(new Configuration());
		//FSDataOutputStream out = fs.create(new Path(loc), true, (2048*2048*20));
		FSDataOutputStream out = fs.create(new Path(loc));
		
		//BufferedOutputStream out = new BufferedOutputStream(fout);
		
		Codec.Encoder cellEncoder = codec.getEncoder(out);
		int MUTATIONS = columns * rows;
		
		
		System.out.println("Building word list");
		buildListFromFile(words);
		System.out.println("Word list built");
		
		int wordListLength = wordList.size();
		System.out.println("Num words " + wordListLength);
		if (entropy < 0 || entropy > wordListLength) {
			entropy = wordListLength;
		}
		
		long stopTime, startTime = System.currentTimeMillis();
		long tempStop, tempStart;
		double elapsed, writingElapsed = 0, constructorElapsed = 0;
		for (int i = 0; i < rows; i++) {
			//byte[] row = new String("row" + i).getBytes();
			byte[] row = "row".getBytes();
			
			
			for (int j = 0; j < columns; j++) {
				//byte[] family = randomWord(entropy);
				byte[] family = "family".getBytes();
				//byte[] qualifier = randomWord(entropy);
				byte[] qualifier = "qualifier".getBytes();
				//byte[] value = randomWord(wordListLength);
				byte[] value = "value".getBytes();
				tempStart = System.currentTimeMillis();
				
				
				//KeyValue kv = new KeyValue(row, family, qualifier, value);
				
				
				WritableKeyValue kv = new WritableKeyValue(row, 0, row.length, family, 0, family.length,
										qualifier, 0, qualifier.length, startTime, Type.Put,
												value, 0, value.length, null);
				
				
				tempStop = System.currentTimeMillis();
				constructorElapsed += (tempStop - tempStart) / 1000.0;
				//System.out.println("Constructor time: " + elapsed);
				
				tempStart = System.currentTimeMillis();
				kv.setCompression(compressionContext);
				kv.write(out);
				
				//cellEncoder.write(kv);
				
				tempStop = System.currentTimeMillis();
				writingElapsed += (tempStop - tempStart) / 1000.0;
				//System.out.println(out.size());
				//System.out.println("write time: " + elapsed);
				//cellEncoder.write(kv);
			}
			if (i % 10 == 0) {
				out.flush();
				//cellEncoder.flush();
			}
			
		}
		
		stopTime = System.currentTimeMillis();
	    out.close();
	    fs.close();
	    int totalValues = MUTATIONS;
	    elapsed = (stopTime - startTime) / 1000.0;
	    
	    System.out.printf("%,12d records written | %,8d records/sec |  %6.3f secs   %n", totalValues,
	        (int) (totalValues / elapsed), elapsed);
	    System.out.println("time spent writing: " + writingElapsed);
	    System.out.println("time spent in constructor: " + constructorElapsed);
	}
}
